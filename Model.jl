using Flux
using Enzyme
using LinearAlgebra
using Random

# 1. Material parameters
E = 210e3 # MPa Youngâ€™s modulus
Î½ = 0.3 # Poissonâ€™s ratio
G =  Float32(E/(2*(1+Î½))) # Shear Modulus
K = Float32(E/(3*(1-2*Î½))) # Bulk Modulus
Y0 = Float32(350.0) # MPa Initial stress of the material Y0 comes from a tensile test or compression test.
t_star = Float32(1.0) # _star and n_exp Parameters for viscoplastic flow (flow rate exponent and characteristic time).
n_exp = 1
NN0 = Float32(1.0) # Scaling factor for neural network outputs.

println("Material parameters: G=$G, K=$K, Y0=$Y0")

# 2. Material state
mutable struct MaterialState{T<:AbstractFloat}
    Îµp::Matrix{T}  # plastic strain
    Î²::Matrix{T}   # backstress
    Îº::T           # isotropic hardening
end

#Stores internal variables that evolve over time: plastic strain, backstress, and isotropic hardening(represents the uniform expansion of the yield surface in stress space).

function MaterialStateZero(::Type{T}=Float32) where T<:AbstractFloat
    #At the very beginning of a simulation, before any load is applied, the material is assumed undeformed and unstressed.
    #Plastic strain Îµp = 0 â†’ material has not plastically deformed yet.
    #Backstress Î² = 0 â†’ no internal stress has accumulated.
    #Isotropic hardening Îº = 0 â†’ no hardening has occurred.
    MaterialState{T}(zeros(T,3,3), zeros(T,3,3), zero(T))
end

# 3. Helper functions
function double_dot(A::AbstractMatrix{<:AbstractFloat}, B::AbstractMatrix{<:AbstractFloat})
    return Float32(sum(Float32.(A) .* Float32.(B)))
end

#.* is element-wise multiplication in Julia.
#Adds all the numbers in the resulting matrix.
#double contraction in tensor #https://github.com/KeitaNakamura/Tensorial.jl âŠ¡â‚‚

function deviatoric(T_::AbstractMatrix{T}) where T<:AbstractFloat
    return T_ .- (tr(T_)/3.0) * Matrix{T}(I(3))
end
#remove the mean/volumetric part of a tensor â†’ leave only shear/deviatoric part.
#Essential for plasticity models because plastic deformation depends on deviatoric stress, not hydrostatic pressure.

function yield_vonMises(Ïƒ::AbstractMatrix{T}, Î²::AbstractMatrix{T}, Îº::T, Y0::T) where T<:AbstractFloat
    # Von Mises yield function with kinematic (Î²) and isotropic (Îº) hardening
    # Returns >0 if yielding occurs, â‰¤0 if elastic
    Ïƒf = Float32.(Ïƒ)
    Î²f = Float32.(Î²)

    s = Ïƒf .- Î²f
    s_dev = deviatoric(s)
    Ïƒ_eq = sqrt(Float32(3/2) * double_dot(s_dev, s_dev))
    return Ïƒ_eq - (Y0 + Îº)
end

function flow_direction(Ïƒ::AbstractMatrix{T}, Î²::AbstractMatrix{T}) where T<:AbstractFloat
    #Î½ = (3/2)*((dev(Ïƒ) - dev(Î²)) / f_vM (Ïƒ-Î²))
    #Î½=(âˆ‚Ïƒ/âˆ‚Î¦)â€‹ = plastic flow direction (normal to yield surface, associative plasticity).
    Ïƒf = Float32.(Ïƒ)
    Î²f = Float32.(Î²)
    s = Ïƒf .- Î²f
    s_dev = deviatoric(s)
    Ïƒ_dev = deviatoric(Ïƒf)
    Î²_dev = deviatoric(Î²f)
    f_vM = sqrt((3/2) * double_dot(s, s_dev))
    if f_vM < 1e-14
        return zeros(3,3)  # avoid division by zero
    else
        Î½ = (3/2) * ((Ïƒ_dev-Î²_dev)/f_vM)
        return Î½
    end
end

function compute_invariants(state::MaterialState{T}, Î½::AbstractMatrix{T}, NN0::T) where T<:AbstractFloat
    # Ensure all state variables are of type T
    Î² = state.Î²      # backstress tensor
    Îµp = state.Îµp    # plastic strain tensor
    Îº = state.Îº      # isotropic hardening (scalar)

    # ----------------------------
    # Compute invariants
    # ----------------------------
    I1 = Îº / NN0
    I2 = double_dot(Î², Î²) / (NN0^2)
    I3 = double_dot(Î½, Î²) / NN0
    I4 = double_dot(Î², Îµp) / (NN0^2)
    I5 = double_dot(Î½, Îµp) / NN0
    I6 = double_dot(Îµp, Îµp) / (NN0^2)

    return T[I1, I2, I3, I4, I5, I6]  # return as vector of type T
end



function evolution_laws(state::MaterialState, Î½::Matrix{Float32}, Î»dot::Float32, NN_output::Vector{Float32}, NN0::Float32)
    #Proposed evolution laws using NN outputs:
    #bË™=âˆ’Î»Ë™[(1âˆ’(Î½:Î²)â€‰NNk,Î½)Î½âˆ’NNk,Î²Î²]
    #ÎºË™=âˆ’Î»Ë™[1âˆ’Îºâ€‰NN iso]
    # Neural net outputs
    NN_iso, NN_kÎ², NN_kÎ½ = NN_output[1:3]

    # Flow interaction
    tr_dot = double_dot(Î½, state.Î²) / NN0   # <-- scale Î² consistently

    # Backstress evolution (scaled)
    Î²_dot = -Î»dot * (((1 - tr_dot * NN_kÎ½) * Î½) - (NN_kÎ² * state.Î² / NN0))

    # Isotropic hardening (scaled)
    Îº_dot = Î»dot * (1 + NN_iso) * NN0
    return Î²_dot, Îº_dot
end

# 4. Elastic stress 

function elastic_stress(Îµ::AbstractMatrix{T}, state::MaterialState{T}, G::T, K::T) where T<:AbstractFloat
    # Elastic stiffness tensor (E):
    # relates stress and strain via:
    #     Ïƒ = C : Îµ
    # where ":" denotes the double-dot product.
    #
    # For a 3D isotropic material:
    #   - Ïƒ = stress tensor (3x3)
    #   - Îµ = strain tensor (3x3)
    #   - C encodes the material's elastic properties.
    #
    # The stress-strain relation can be written as:
    #     Ïƒ = 2*G*Îµ_dev + K*tr(Îµ)*I
    # shear stress (distortional part) + volumetric stress (hydrostatic part),
    # where:
    #   - G is the shear modulus
    #   - K is the bulk modulus
    #   - Îµ_dev = deviatoric part of strain = Îµ - (tr(Îµ)/3)*I
    #   - tr(Îµ) = trace of strain (volumetric part)
    #   - I = 3x3 identity matrix
    #For an isotropic material, the elasticity matrix in Voigt notation is: https://doc.comsol.com/5.5/doc/com.comsol.help.sme/sme_ug_theory.06.23.html
    # This formula is equivalent to the derivative of the elastic energy density:
    #     Î¨_e = 1/2 * (Îµ - Îµ_p) : C : (Îµ - Îµ_p)
    # with respect to Îµ, where Îµ_p is the plastic strain.

    Îµe = Îµ .- state.Îµp
    return 2*G*deviatoric(Îµe) + K*tr(Îµe)*Matrix{T}(I(3))
end

# 5. Time integration (3D)

function integrate_material_3D(nn, Îµ_hist_3D, dt, G, K, Y0, n, t_star, NN0)
    # Inputs:
    # nn â†’ the neural network that predicts evolution law parameters from invariants.
    # Îµ_hist_3D â†’ history of strain tensors over time (3Ã—3 matrices).
    # dt â†’ time step increment.
    # G, K â†’ shear and bulk modulus (elastic properties).
    # Y0 â†’ initial yield stress.
    # n â†’ exponent for the viscoplastic flow rate.
    # t_star â†’ characteristic time.
    # NN0 â†’ scaling factor for neural network outputs.
    # Output:
    # Ïƒ_hist â†’ list of stress tensors computed at each time step.
    state = MaterialStateZero()
    #starting material state (plastic strain, backstress, isotropic hardening all zero).
    nt = length(Îµ_hist_3D)
    Ïƒ_hist = [zeros(3,3) for i in 1:nt] #empty array to store the stress at each time step.

    for i in 1:nt
        println("\n===============================")
        println("ðŸ”¹ Time step: $i / $nt")
        println("===============================")

        # --- Strain history ---
        Îµ = Îµ_hist_3D[i]
        println("Îµ (strain tensor):\n$Îµ")

        # --- Elastic predictor ---
        Ïƒ = Float32.(elastic_stress(Îµ, state, G, K))
        println("Ïƒ (elastic stress tensor):\n$Ïƒ")

        # --- Flow direction ---
        Î½ = Float32.(flow_direction(Ïƒ, state.Î²))
        println("Î½ (flow direction):\n$Î½")

        # --- Invariants for NN input ---
        invariants = compute_invariants(state, Î½, NN0)
        println("Invariants (NN input): ", invariants)

        # --- Neural network output ---
        NN_input = reshape(Float32.(invariants), :, 1)
        NN_output = Float32.(vec(nn(Float32.(NN_input))))
        println("NN input (reshaped): ", NN_input)
        println("NN output: ", NN_output)

        # --- Yield function ---
        Î¦ = yield_vonMises(Ïƒ, state.Î², state.Îº, Y0)
        println("Yield function Î¦: ", Î¦)

        # --- Plastic multiplier ---
        Î»dot = max(0, (Î¦ / Y0)^n / t_star)
        println("Î»Ì‡ (plastic multiplier rate): ", Î»dot)

        # --- Evolution laws ---
        Î²_dot, Îº_dot = evolution_laws(state, Î½, Î»dot, NN_output, NN0)
        println("Î²Ì‡ (backstress rate):\n$Î²_dot")
        println("ÎºÌ‡ (hardening variable rate): ", Îº_dot)

        # --- State updates ---
        state.Î² .+= Î²_dot .* dt
        state.Îº  += Îº_dot * dt
        state.Îµp .+= Î»dot .* Î½ .* dt
        println("Updated backstress Î²:\n", state.Î²)
        println("Updated Îº: ", state.Îº)
        println("Updated plastic strain Îµp:\n", state.Îµp)

        # --- Store history ---
        Ïƒ_hist[i] .= Ïƒ
        println("Stored Ïƒ_hist[$i]:\n", Ïƒ_hist[i])
    end

    return Ïƒ_hist

end


# 6. Neural Network (3D invariants â†’ evolution)
nn = Chain(
    Dense(6,6,tanh),
    Dense(6,6,tanh),
    Dense(6,6,tanh),
    Dense(6,6,tanh),
    Dense(6,5,tanh),
    Dense(5,3,x->x.^2) #One Dense(5 â†’ 3, x -> x.^2) â†’ output layer with 3 neurons, using squared activation
)
# W = weight matrix, shape (out_dim, in_dim), initialized with standard normal values.
# b = bias vector of length out_dim, initialized to zeros.
# Returns a Dense layer (from Flux.jl) with these weights, biases, and the specified activation.

dup_nn = Enzyme.Duplicated(nn)

# 7. Loss function (3D)

# Ïƒ = [Ïƒxx Ïƒyx Ïƒzx; Ïƒxy Ïƒyy Ïƒzy; Ïƒxz Ïƒyz Ïƒzz]
function loss_exact_paper(Ïƒ_sim::Vector{<:AbstractMatrix{<:AbstractFloat}}, 
                          Ïƒ_exp::Vector{<:AbstractMatrix{<:AbstractFloat}};
                          w_g::Float32=Float32(1.0), delta_l::Int=10)
    Nstp = length(Ïƒ_sim)
    ncomp = size(Ïƒ_sim[1], 1)

    # Compute global stress range
    smin = minimum([Ïƒ_exp[l][a,b] for l in 1:Nstp, a in 1:ncomp, b in 1:ncomp])
    smax = maximum([Ïƒ_exp[l][a,b] for l in 1:Nstp, a in 1:ncomp, b in 1:ncomp])
    range_exp = smax - smin + 1e-12

    # Normalized L2 loss
    loss_L2 = 0.0
    for l in 1:Nstp
        for i in 1:ncomp, j in 1:ncomp
            d = (Float32(Ïƒ_sim[l][i,j]) - Float32(Ïƒ_exp[l][i,j])) / (sqrt(Nstp) * Float32(range_exp))
            loss_L2 += d^2
        end
    end

    # Sobolev term
    loss_sobolev = 0.0
    for l in 1:(Nstp - delta_l)
        for i in 1:ncomp, j in 1:ncomp
            Î”sim = Float32(Ïƒ_sim[l+delta_l][i,j]) - Float32(Ïƒ_sim[l][i,j])
            Î”exp = Float32(Ïƒ_exp[l+delta_l][i,j]) - Float32(Ïƒ_exp[l][i,j])
            d = (Î”sim - Î”exp) / (sqrt(Nstp) * Float32(range_exp))
            loss_sobolev += w_g * d^2
        end
    end
    tot_loss=loss_L2 + loss_sobolev
    println("\n=== Loss $tot_loss ===")
    return tot_loss
end


# Lame constants
Î» = (E*Î½) / ((1+Î½)*(1-2Î½))
Î¼ = E / (2*(1+Î½))   # shear modulus

# build stiffness tensor C (Voigt 6x6 form)
C_voigt = [
    Î»+2Î¼   Î»      Î»      0     0     0
    Î»     Î»+2Î¼    Î»      0     0     0
    Î»      Î»     Î»+2Î¼    0     0     0
    0      0      0      Î¼     0     0
    0      0      0      0     Î¼     0
    0      0      0      0     0     Î¼
]

# helper to convert strain tensor (3x3) to Voigt vector (6x1)
function tensor_to_voigt(Îµ::AbstractMatrix{T}) where T<:AbstractFloat
    return T[
        Îµ[1,1];
        Îµ[2,2];
        Îµ[3,3];
        2*Îµ[2,3];
        2*Îµ[1,3];
        2*Îµ[1,2];
    ]
end

# and back: Voigt vector â†’ 3x3 stress tensor
function voigt_to_tensor(Ïƒv::AbstractVector{T}) where T<:AbstractFloat
    return T[
        Ïƒv[1]  Ïƒv[6]/2  Ïƒv[5]/2;
        Ïƒv[6]/2 Ïƒv[2]   Ïƒv[4]/2;
        Ïƒv[5]/2 Ïƒv[4]/2 Ïƒv[3]
    ]
end

# Strain history (uniaxial loading in z-direction) simulates a uniaxial tensile test.
nt = 30
Îµ_hist_3D = [Float32.(Matrix(Diagonal([0.0, 0.0, Îµ]))) for Îµ in range(0, 0.02, length=nt)]
println("\n=== Strain $Îµ_hist_3D ===")
# Compute consistent stresses
C_voigt = Float32.(C_voigt)
Ïƒ_exp_3D = [Float32.(voigt_to_tensor(C_voigt * tensor_to_voigt(Îµ))) for Îµ in Îµ_hist_3D]
println("\n=== Stress $Ïƒ_exp_3D ===")

epochs = 10
dt = 0.01 #time increment for material simulation.
#Each step in your strain history is assumed to happen at intervals of dt.

optimizer = Flux.setup(RAdam(1e-3), nn)
#the RAdam optimizer with learning rate 0.001(Since in the paper specific value is not given am using a common value)

for step in 1:epochs
    println("\n=== Training step $step ===")
    
    grads = Flux.gradient((m, Îµ, Ïƒ) -> 
        loss_exact_paper(
            integrate_material_3D(m, Îµ, dt, G, K, Y0, n_exp, t_star, NN0),
            Ïƒ
        ), 
        dup_nn, Const(Îµ_hist_3D), Const(Ïƒ_exp_3D)
    )
    
    # Update original neural network
    Flux.update!(optimizer, nn, grads[1])
end
